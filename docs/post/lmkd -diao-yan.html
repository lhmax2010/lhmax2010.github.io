<!DOCTYPE html>
<html data-color-mode="light" data-dark-theme="dark" data-light-theme="light" lang="zh-CN">
<head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link href='https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/Primer/21.0.7/primer.css' rel='stylesheet' />
    
    <link rel="icon" href="https://github.githubassets.com/favicons/favicon.svg"><script>
        let theme = localStorage.getItem("meek_theme") || "light";
        document.documentElement.setAttribute("data-color-mode", theme);
    </script>
<meta name="description" content="lmkd流程图
sequenceDiagram
autonumber
participant AMS as AMS
participant PL as ProcessList
participant KPSI as Kernel PSI
participant KVM as Kernel vmpressure
participant LMK as lmkd main
participant CTRL as ctrl handler
participant PSI as psi handler
participant VMP as vmpressure handler
participant PRIO as procprio handler
participant KILL as killer

%% Startup
AMS->>LMK: main - lmkd.c - entry start lmkd
LMK->>LMK: init - lmkd.c - init data and minfree
LMK->>LMK: init_sock - lmkd.c - create ctrl socket
LMK->>LMK: init_cgroup - lmkd.c - setup memcg paths
LMK->>LMK: epoll_main_loop - lmkd.c - register fds and loop

%% AMS & ProcessList scoring
AMS->>PL: computeOomAdjLocked - ProcessList.java - compute oom_score_adj
PL-->>AMS: return oom_score_adj
AMS->>LMK: send procprio via ctrl socket
LMK->>PRIO: procprio_handler - lmkd.c - handle priority message
PRIO->>PRIO: proc_setprio - lmkd.c - update procprio table

%% Control commands
AMS-->>LMK: ctrl command minfree or procprio or kill
LMK->>CTRL: ctrl_handler - lmkd.c - receive command
CTRL->>CTRL: ctrl_command_handler - lmkd.c - parse command
alt set minfree
  CTRL->>CTRL: cmd_target - lmkd.c - update minfree thresholds
else update procprio
  CTRL->>PRIO: cmd_procprio - lmkd.c - refresh priority table
else force kill
  CTRL->>KILL: cmd_kill - lmkd.c - trigger kill path
end

%% PSI event with decision gates
KPSI-->>LMK: PSI event from /proc/pressure/memory
LMK->>PSI: psi_event_handler - lmkd_psi.c - psi event entry
PSI->>PSI: handle_psi_event - lmkd_psi.c - read psi metrics
PSI->>PSI: evaluate_thrashing - lmkd_psi.c - compute thrashing ratio
alt Gate1 threshold reached
  PSI->>PSI: compute distance_to_threshold - hysteresis
  alt Gate2 distance small enough
    PSI->>PSI: check_backoff - rate limit
    alt Gate3 backoff expired
      alt Gate4 thrashing high
        PSI->>KILL: do_kill - lmkd.c - enter kill path
      else thrashing low
        PSI-->>LMK: return to loop
      end
    else backoff not expired
      PSI-->>LMK: return to loop
    end
  else distance too large
    PSI-->>LMK: return to loop
  end
else threshold not reached
  PSI-->>LMK: return to loop
end

%% vmpressure path
KVM-->>LMK: vmpressure event
LMK->>VMP: vmpressure_handler - lmkd_vmpressure.c - entry
VMP->>VMP: handle_vmpressure - lmkd_vmpressure.c - process pressure level
VMP->>VMP: update_reclaim_targets - lmkd_vmpressure.c - tune reclaim
VMP-->>LMK: return to loop

%% Kill path using AMS scores
KILL->>KILL: kill_some_processes - lmkd.c - collect meminfo and psi
KILL->>KILL: find_victim_process - lmkd.c - build candidate list
KILL->>KILL: proc_adj_sort - lmkd.c - sort by adj rss swapin refault
KILL->>KILL: select_and_kill_process - lmkd.c - pick victim
KILL->>KILL: send_sigkill - lmkd.c - send SIGKILL
KILL->>KILL: reclaim_pages_wait - lmkd.c - wait reclaim
KILL->>AMS: stats_write - lmkd_stats.c - report to statsd and AM
KILL-->>LMK: back to epoll loop

lmkd的优化思路
0. 目标与总览

目标：将 lmkd 从“只会杀”升级为动作阶梯（限流→降温→杀），支持cgroup 保护/处置、多信号融合（PSI+IO/CPU+内核统计）、自适应 backoff、可观测性完善，并在低端/无 PSI内核上有兜底。">
<meta property="og:title" content="lmkd 调研">
<meta property="og:description" content="lmkd流程图
sequenceDiagram
autonumber
participant AMS as AMS
participant PL as ProcessList
participant KPSI as Kernel PSI
participant KVM as Kernel vmpressure
participant LMK as lmkd main
participant CTRL as ctrl handler
participant PSI as psi handler
participant VMP as vmpressure handler
participant PRIO as procprio handler
participant KILL as killer

%% Startup
AMS->>LMK: main - lmkd.c - entry start lmkd
LMK->>LMK: init - lmkd.c - init data and minfree
LMK->>LMK: init_sock - lmkd.c - create ctrl socket
LMK->>LMK: init_cgroup - lmkd.c - setup memcg paths
LMK->>LMK: epoll_main_loop - lmkd.c - register fds and loop

%% AMS & ProcessList scoring
AMS->>PL: computeOomAdjLocked - ProcessList.java - compute oom_score_adj
PL-->>AMS: return oom_score_adj
AMS->>LMK: send procprio via ctrl socket
LMK->>PRIO: procprio_handler - lmkd.c - handle priority message
PRIO->>PRIO: proc_setprio - lmkd.c - update procprio table

%% Control commands
AMS-->>LMK: ctrl command minfree or procprio or kill
LMK->>CTRL: ctrl_handler - lmkd.c - receive command
CTRL->>CTRL: ctrl_command_handler - lmkd.c - parse command
alt set minfree
  CTRL->>CTRL: cmd_target - lmkd.c - update minfree thresholds
else update procprio
  CTRL->>PRIO: cmd_procprio - lmkd.c - refresh priority table
else force kill
  CTRL->>KILL: cmd_kill - lmkd.c - trigger kill path
end

%% PSI event with decision gates
KPSI-->>LMK: PSI event from /proc/pressure/memory
LMK->>PSI: psi_event_handler - lmkd_psi.c - psi event entry
PSI->>PSI: handle_psi_event - lmkd_psi.c - read psi metrics
PSI->>PSI: evaluate_thrashing - lmkd_psi.c - compute thrashing ratio
alt Gate1 threshold reached
  PSI->>PSI: compute distance_to_threshold - hysteresis
  alt Gate2 distance small enough
    PSI->>PSI: check_backoff - rate limit
    alt Gate3 backoff expired
      alt Gate4 thrashing high
        PSI->>KILL: do_kill - lmkd.c - enter kill path
      else thrashing low
        PSI-->>LMK: return to loop
      end
    else backoff not expired
      PSI-->>LMK: return to loop
    end
  else distance too large
    PSI-->>LMK: return to loop
  end
else threshold not reached
  PSI-->>LMK: return to loop
end

%% vmpressure path
KVM-->>LMK: vmpressure event
LMK->>VMP: vmpressure_handler - lmkd_vmpressure.c - entry
VMP->>VMP: handle_vmpressure - lmkd_vmpressure.c - process pressure level
VMP->>VMP: update_reclaim_targets - lmkd_vmpressure.c - tune reclaim
VMP-->>LMK: return to loop

%% Kill path using AMS scores
KILL->>KILL: kill_some_processes - lmkd.c - collect meminfo and psi
KILL->>KILL: find_victim_process - lmkd.c - build candidate list
KILL->>KILL: proc_adj_sort - lmkd.c - sort by adj rss swapin refault
KILL->>KILL: select_and_kill_process - lmkd.c - pick victim
KILL->>KILL: send_sigkill - lmkd.c - send SIGKILL
KILL->>KILL: reclaim_pages_wait - lmkd.c - wait reclaim
KILL->>AMS: stats_write - lmkd_stats.c - report to statsd and AM
KILL-->>LMK: back to epoll loop

lmkd的优化思路
0. 目标与总览

目标：将 lmkd 从“只会杀”升级为动作阶梯（限流→降温→杀），支持cgroup 保护/处置、多信号融合（PSI+IO/CPU+内核统计）、自适应 backoff、可观测性完善，并在低端/无 PSI内核上有兜底。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://lhmax2010.github.io/post/lmkd%20-diao-yan.html">
<meta property="og:image" content="https://github.githubassets.com/favicons/favicon.svg">
<title>lmkd 调研</title>



</head>
<style>
body{box-sizing: border-box;min-width: 200px;max-width: 900px;margin: 20px auto;padding: 45px;font-size: 16px;font-family: sans-serif;line-height: 1.25;}
#header{display:flex;padding-bottom:8px;border-bottom: 1px solid var(--borderColor-muted, var(--color-border-muted));margin-bottom: 16px;}
#footer {margin-top:64px; text-align: center;font-size: small;}

</style>

<style>
.postTitle{margin: auto 0;font-size:40px;font-weight:bold;}
.title-right{display:flex;margin:auto 0 0 auto;}
.title-right .circle{padding: 14px 16px;margin-right:8px;}
#postBody{border-bottom: 1px solid var(--color-border-default);padding-bottom:36px;}
#postBody hr{height:2px;}
#cmButton{height:48px;margin-top:48px;}
#comments{margin-top:64px;}
.g-emoji{font-size:24px;}
@media (max-width: 600px) {
    body {padding: 8px;}
    .postTitle{font-size:24px;}
}

</style>




<body>
    <div id="header">
<h1 class="postTitle">lmkd 调研</h1>
<div class="title-right">
    <a href="https://lhmax2010.github.io" id="buttonHome" class="btn btn-invisible circle" title="首页">
        <svg class="octicon" width="16" height="16">
            <path id="pathHome" fill-rule="evenodd"></path>
        </svg>
    </a>
    
    <a href="https://github.com/lhmax2010/lhmax2010.github.io/issues/13" target="_blank" class="btn btn-invisible circle" title="Issue">
        <svg class="octicon" width="16" height="16">
            <path id="pathIssue" fill-rule="evenodd"></path>
        </svg>
    </a>
    

    <a class="btn btn-invisible circle" onclick="modeSwitch();" title="切换主题">
        <svg class="octicon" width="16" height="16" >
            <path id="themeSwitch" fill-rule="evenodd"></path>
        </svg>
    </a>

</div>
</div>
    <div id="content">
<div class="markdown-body" id="postBody"><p>lmkd流程图<br>
sequenceDiagram<br>
autonumber<br>
participant AMS as AMS<br>
participant PL as ProcessList<br>
participant KPSI as Kernel PSI<br>
participant KVM as Kernel vmpressure<br>
participant LMK as lmkd main<br>
participant CTRL as ctrl handler<br>
participant PSI as psi handler<br>
participant VMP as vmpressure handler<br>
participant PRIO as procprio handler<br>
participant KILL as killer</p>
<p>%% Startup<br>
AMS-&gt;&gt;LMK: main - lmkd.c - entry start lmkd<br>
LMK-&gt;&gt;LMK: init - lmkd.c - init data and minfree<br>
LMK-&gt;&gt;LMK: init_sock - lmkd.c - create ctrl socket<br>
LMK-&gt;&gt;LMK: init_cgroup - lmkd.c - setup memcg paths<br>
LMK-&gt;&gt;LMK: epoll_main_loop - lmkd.c - register fds and loop</p>
<p>%% AMS &amp; ProcessList scoring<br>
AMS-&gt;&gt;PL: computeOomAdjLocked - ProcessList.java - compute oom_score_adj<br>
PL--&gt;&gt;AMS: return oom_score_adj<br>
AMS-&gt;&gt;LMK: send procprio via ctrl socket<br>
LMK-&gt;&gt;PRIO: procprio_handler - lmkd.c - handle priority message<br>
PRIO-&gt;&gt;PRIO: proc_setprio - lmkd.c - update procprio table</p>
<p>%% Control commands<br>
AMS--&gt;&gt;LMK: ctrl command minfree or procprio or kill<br>
LMK-&gt;&gt;CTRL: ctrl_handler - lmkd.c - receive command<br>
CTRL-&gt;&gt;CTRL: ctrl_command_handler - lmkd.c - parse command<br>
alt set minfree<br>
CTRL-&gt;&gt;CTRL: cmd_target - lmkd.c - update minfree thresholds<br>
else update procprio<br>
CTRL-&gt;&gt;PRIO: cmd_procprio - lmkd.c - refresh priority table<br>
else force kill<br>
CTRL-&gt;&gt;KILL: cmd_kill - lmkd.c - trigger kill path<br>
end</p>
<p>%% PSI event with decision gates<br>
KPSI--&gt;&gt;LMK: PSI event from /proc/pressure/memory<br>
LMK-&gt;&gt;PSI: psi_event_handler - lmkd_psi.c - psi event entry<br>
PSI-&gt;&gt;PSI: handle_psi_event - lmkd_psi.c - read psi metrics<br>
PSI-&gt;&gt;PSI: evaluate_thrashing - lmkd_psi.c - compute thrashing ratio<br>
alt Gate1 threshold reached<br>
PSI-&gt;&gt;PSI: compute distance_to_threshold - hysteresis<br>
alt Gate2 distance small enough<br>
PSI-&gt;&gt;PSI: check_backoff - rate limit<br>
alt Gate3 backoff expired<br>
alt Gate4 thrashing high<br>
PSI-&gt;&gt;KILL: do_kill - lmkd.c - enter kill path<br>
else thrashing low<br>
PSI--&gt;&gt;LMK: return to loop<br>
end<br>
else backoff not expired<br>
PSI--&gt;&gt;LMK: return to loop<br>
end<br>
else distance too large<br>
PSI--&gt;&gt;LMK: return to loop<br>
end<br>
else threshold not reached<br>
PSI--&gt;&gt;LMK: return to loop<br>
end</p>
<p>%% vmpressure path<br>
KVM--&gt;&gt;LMK: vmpressure event<br>
LMK-&gt;&gt;VMP: vmpressure_handler - lmkd_vmpressure.c - entry<br>
VMP-&gt;&gt;VMP: handle_vmpressure - lmkd_vmpressure.c - process pressure level<br>
VMP-&gt;&gt;VMP: update_reclaim_targets - lmkd_vmpressure.c - tune reclaim<br>
VMP--&gt;&gt;LMK: return to loop</p>
<p>%% Kill path using AMS scores<br>
KILL-&gt;&gt;KILL: kill_some_processes - lmkd.c - collect meminfo and psi<br>
KILL-&gt;&gt;KILL: find_victim_process - lmkd.c - build candidate list<br>
KILL-&gt;&gt;KILL: proc_adj_sort - lmkd.c - sort by adj rss swapin refault<br>
KILL-&gt;&gt;KILL: select_and_kill_process - lmkd.c - pick victim<br>
KILL-&gt;&gt;KILL: send_sigkill - lmkd.c - send SIGKILL<br>
KILL-&gt;&gt;KILL: reclaim_pages_wait - lmkd.c - wait reclaim<br>
KILL-&gt;&gt;AMS: stats_write - lmkd_stats.c - report to statsd and AM<br>
KILL--&gt;&gt;LMK: back to epoll loop</p>
<p>lmkd的优化思路<br>
0. 目标与总览</p>
<p>目标：将 lmkd 从“只会杀”升级为动作阶梯（限流→降温→杀），支持cgroup 保护/处置、多信号融合（PSI+IO/CPU+内核统计）、自适应 backoff、可观测性完善，并在低端/无 PSI内核上有兜底。</p>
<p>改动涉及文件：</p>
<p>lmkd.c（事件循环 / ctrl / kill / 选择器 / backoff）</p>
<p>lmkd_psi.c（PSI 读取与 Gate 判定，融合 IO/CPU PSI）</p>
<p>lmkd_vmpressure.c（阈值动态调整）</p>
<p>lmkd_stats.c（统计扩展）</p>
<p>新增：lmkd_cgroup.c/.h（cgroup v2 写入与组操作）、lmkd_actions.c/.h（动作阶梯与 pre-actions）、lmkd_config.c/.h（属性/设备策略装载）</p>
<p>编译脚本：修改 Android.bp 增加新源文件与 LOCAL_CFLAGS 开关。</p>
<ol>
<li>动作阶梯（pre-actions hook）</li>
</ol>
<p>思路：触发 Gate 后先进行「温和动作」：对候选的低优先级进程/组写 memory.high、对其地址空间做 process_madvise(MADV_COLD/PAGEOUT) 或 Compaction；仅在压力未缓解时才进入 kill。</p>
<p>新增：lmkd_actions.h/.c<br>
`// lmkd_actions.h<br>
#pragma once<br>
#include &lt;stdbool.h&gt;<br>
#include &lt;sys/types.h&gt;</p>
<p>typedef enum {<br>
ACT_NONE = 0,<br>
ACT_SET_MEMORY_HIGH,<br>
ACT_MADVISE_COLD,<br>
ACT_MADVISE_PAGEOUT,<br>
ACT_GROUP_THROTTLE,<br>
} action_t;</p>
<p>typedef struct {<br>
bool   enable;<br>
float  memory_high_ratio;   // 相对进程RSS或cgroup current的比例(如0.8)<br>
size_t cold_bytes;          // MADV_COLD/PAGEOUT 的目标字节数(0=全地址空间)<br>
int    cooldown_ms;         // pre-action后观察窗口<br>
} preaction_policy_t;</p>
<p>bool preactions_try_throttle_pid(pid_t pid, const preaction_policy_t* pol);<br>
bool preactions_try_group_throttle(const char* cg_path, const preaction_policy_t* pol);<br>
bool preactions_try_madvise_cold(pid_t pid, size_t bytes);<br>
<code class="notranslate"> </code>// lmkd_actions.c (核心片段)<br>
#include "lmkd_actions.h"<br>
#include "lmkd_cgroup.h"<br>
#include &lt;unistd.h&gt;<br>
#include &lt;sys/syscall.h&gt;<br>
#include &lt;linux/membarrier.h&gt;</p>
<p>// 简化：通过 /proc//cgroup 解析出 cgroup v2 路径<br>
static bool throttle_pid_cgroup(pid_t pid, float ratio) {<br>
char cg[PATH_MAX];<br>
if (!cg2_path_by_pid(pid, cg, sizeof(cg))) return false;<br>
// 读取当前使用量 memory.current<br>
long cur = cg2_read_long(cg, "memory.current");<br>
long high = (long)(cur * ratio);<br>
// 写 memory.high 节流<br>
return cg2_write_long(cg, "memory.high", high);<br>
}</p>
<p>bool preactions_try_throttle_pid(pid_t pid, const preaction_policy_t* pol) {<br>
if (!pol || !pol-&gt;enable) return false;<br>
return throttle_pid_cgroup(pid, pol-&gt;memory_high_ratio);<br>
}</p>
<p>bool preactions_try_group_throttle(const char* cg, const preaction_policy_t* pol) {<br>
if (!pol || !pol-&gt;enable) return false;<br>
long cur = cg2_read_long(cg, "memory.current");<br>
long high = (long)(cur * pol-&gt;memory_high_ratio);<br>
return cg2_write_long(cg, "memory.high", high);<br>
}</p>
<p>static int sys_process_madvise(int pidfd, void* addr, size_t len, int advice, unsigned long flag) {<br>
#ifdef SYS_process_madvise<br>
return syscall(SYS_process_madvise, pidfd, addr, len, advice, flag);<br>
#else<br>
return -1;<br>
#endif<br>
}</p>
<p>bool preactions_try_madvise_cold(pid_t pid, size_t bytes) {<br>
// 通过 pidfd_open + process_madvise 对整个进程做 MADV_COLD/PAGEOUT<br>
#ifdef SYS_pidfd_open<br>
int pidfd = syscall(SYS_pidfd_open, pid, 0);<br>
if (pidfd &lt; 0) return false;<br>
// 简化：对 NULL 地址传递内核扩展（若不支持则需要遍历maps）<br>
int rc = sys_process_madvise(pidfd, NULL, bytes, 20 /<em>MADV_COLD</em>/, 0);<br>
close(pidfd);<br>
return rc == 0;<br>
#else<br>
return false;<br>
#endif<br>
}<br>
<code class="notranslate">在 lmkd.c 的 kill 流程前插入 pre-actions</code>// lmkd.c 伪代码（在 do_kill() 里开头）<br>
#include "lmkd_actions.h"<br>
#include "lmkd_config.h"</p>
<p>static preaction_policy_t g_prepol;</p>
<p>static bool maybe_preactions(struct proc* cand) {<br>
if (!g_prepol.enable) return false;<br>
bool any = false;<br>
// 只对可牺牲 adj（如 &gt;= CACHED_APP_MIN_ADJ）应用<br>
if (cand-&gt;oom_adj &gt;= g_cfg.preaction_min_adj) {<br>
any |= preactions_try_throttle_pid(cand-&gt;pid, &amp;g_prepol);<br>
if (g_cfg.enable_madvise) {<br>
any |= preactions_try_madvise_cold(cand-&gt;pid, g_prepol.cold_bytes);<br>
}<br>
}<br>
return any;<br>
}</p>
<p>// do_kill() 的开头<br>
if (maybe_preactions(best)) {<br>
// 观察短窗口，若 PSI 下降则短路<br>
if (psi_cooldown_ok(g_prepol.cooldown_ms)) {<br>
LMK_LOG(I, "preaction succeeded, skip kill pid=%d", best-&gt;pid);<br>
record_backoff(/<em>light</em>/true);<br>
return 0;<br>
}<br>
}<br>
<code class="notranslate">2) 按 cgroup 的保护与处置（前台保护、组降级/杀组） 新增：lmkd_cgroup.h/.c（v2 辅助）</code>// lmkd_cgroup.h<br>
bool cg2_path_by_pid(pid_t pid, char* dst, size_t cap);   // 解析 /proc//cgroup<br>
long cg2_read_long(const char* cg, const char* knob);<br>
bool cg2_write_long(const char* cg, const char* knob, long val);<br>
bool cg2_write_str(const char* cg, const char* knob, const char* s);<br>
bool cg2_kill_group(const char* cg, int sig);             // 枚举 cgroup.procs 全杀<br>
<code class="notranslate"> </code>// lmkd_cgroup.c 核心片段<br>
bool cg2_kill_group(const char* cg, int sig) {<br>
char path[PATH_MAX]; snprintf(path, sizeof(path), "%s/cgroup.procs", cg);<br>
FILE* f = fopen(path, "re"); if (!f) return false;<br>
pid_t p; bool ok = false;<br>
while (fscanf(f, "%d", &amp;p) == 1) { kill(p, sig); ok = true; }<br>
fclose(f);<br>
return ok;<br>
}<br>
<code class="notranslate">前台/关键服务保护（在 procprio_handler() 同步 cgroup knobs）</code>// lmkd.c 片段：当接收 adj 更新时，同时设置 cgroup 保护<br>
if (adj &lt;= g_cfg.fg_protect_adj) {<br>
char cg[PATH_MAX];<br>
if (cg2_path_by_pid(pid, cg, sizeof(cg))) {<br>
// 保护前台：避免回收<br>
cg2_write_long(cg, "memory.min", g_cfg.fg_memory_min_bytes);   // 强保护<br>
cg2_write_long(cg, "memory.low", g_cfg.fg_memory_low_bytes);   // 软保护<br>
cg2_write_str(cg, "memory.oom.group", "1");                    // 组处置一致性<br>
}<br>
}<br>
<code class="notranslate">杀组（当候选进程有强耦合子进程）</code>// select_and_kill_process() 内<br>
if (g_cfg.kill_by_group) {<br>
char cg[PATH_MAX];<br>
if (cg2_path_by_pid(victim-&gt;pid, cg, sizeof(cg))) {<br>
cg2_write_str(cg, "memory.oom.group", "1");<br>
cg2_kill_group(cg, SIGKILL);<br>
return;<br>
}<br>
}<br>
kill(victim-&gt;pid, SIGKILL);<br>
`<br>
3) 多信号融合（PSI + IO/CPU PSI + 内核统计）</p>
<p>目标：减少误杀（例如 IO 堵塞导致 PSI 高）。在 evaluate_thrashing() 融合 IO PSI、CPU PSI 与内核统计（pgscan/pgsteal/refault/swapin 速率），形成 stress_score。</p>
<p>在 lmkd_psi.c 扩展<br>
`typedef struct {<br>
float mem_psi;   // memory PSI some or full (一段时间窗口)<br>
float io_psi;    // /proc/pressure/io<br>
float cpu_psi;   // /proc/pressure/cpu<br>
float refault_rate; // 通过 /proc/vmstat 计算<br>
float swapin_rate;  // /proc/vmstat<br>
} signal_vec_t;</p>
<p>static float fuse_stress_score(const signal_vec_t* s) {<br>
// 权重可配置：属性或者 device overlay<br>
const float wm = g_cfg.w_mem_psi;<br>
const float wi = g_cfg.w_io_psi;<br>
const float wc = g_cfg.w_cpu_psi;<br>
const float wr = <code class="notranslate">g_cfg.w_refault;</code><br>
const float ws = g_cfg.w_swapin;<br>
return wm<em>s-&gt;mem_psi + wi</em>s-&gt;io_psi + wc<em>s-&gt;cpu_psi + wr</em>s-&gt;refault_rate + ws*s-&gt;swapin_rate;<br>
}</p>
<p>// evaluate_thrashing() 内<br>
signal_vec_t sv = read_all_signals(window_ms);<br>
float stress = fuse_stress_score(&amp;sv);<br>
bool thrashing_high = (stress &gt;= g_cfg.thrashing_score_thresh);<br>
<code class="notranslate">4) Backoff/退火策略升级（自适应） 在 lmkd.c 维护 backoff</code>typedef struct {<br>
uint64_t last_action_ms;<br>
uint32_t cur_backoff_ms;    // 当前冷却<br>
} backoff_state_t;</p>
<p>static backoff_state_t g_bk;</p>
<p>static void record_backoff(bool light) {<br>
g_bk.last_action_ms = now_ms();<br>
// 自适应：若过去 T 内动作多次，则指数退避<br>
if (!light) g_bk.cur_backoff_ms = min(g_bk.cur_backoff_ms * 2, g_cfg.backoff_ms_max);<br>
else g_bk.cur_backoff_ms = max(g_cfg.backoff_ms_min, g_bk.cur_backoff_ms / 2);<br>
}</p>
<p>static bool backoff_expired(void) {<br>
return (now_ms() - g_bk.last_action_ms) &gt;= g_bk.cur_backoff_ms;<br>
}<br>
<code class="notranslate">PSI Gate3 接入 backoff</code>// lmkd_psi.c 的 Gate3<br>
if (!backoff_expired()) return false; // 不杀，等冷却<br>
<code class="notranslate">5) 候选排序增强（策略表） 在 lmkd.c 的排序器替换为加权多因子</code>typedef struct {<br>
int   adj;           // 来自 AMS<br>
long  rss_kb;<br>
float refault_rate;<br>
float swapin_rate;<br>
int   recent_ui_score; // 最近前台历史，需从 AMS 或 input stats 注入<br>
} victim_feat_t;</p>
<p>static float victim_score(const victim_feat_t* f) {<br>
// adj 越大越容易被杀；recent_ui_score 越大越保留<br>
return g_cfg.w_adj * f-&gt;adj<br>
+ g_cfg.w_rss * (f-&gt;rss_kb/1024.0f)<br>
+ g_cfg.w_refault * f-&gt;refault_rate<br>
+ g_cfg.w_swapin * f-&gt;swapin_rate<br>
- g_cfg.w_ui * f-&gt;recent_ui_score;<br>
}</p>
<p>// sort candidates<br>
qsort(cands, n, sizeof(*cands), cmp_by_victim_score);<br>
<code class="notranslate">6) 可观测性：动作阶梯与原因上报 在 lmkd_stats.c 扩展事件枚举与字段</code>// 增加 PRE_THROTTLE / PRE_COLD / KILL_GROUP 等类型<br>
stats_write_event(EVENT_PREACTION_THROTTLE, pid, stress, psi, backoff_ms);<br>
stats_write_event(EVENT_PREACTION_COLD, pid, bytes, stress);<br>
stats_write_event(EVENT_KILL, pid, reason_code, adj, score);<br>
<code class="notranslate">7) 低端机兜底（无 PSI/裁剪内核） 在 lmkd_psi.c 检测 PSI 不可用时使用 earlyoom 风格触发</code>if (!psi_available) {<br>
long mem_avail = read_memavailable_kb();<br>
long swap_free = read_swapfree_kb();<br>
if (mem_avail &lt; g_cfg.low_mem_kb &amp;&amp; swap_free &lt; g_cfg.low_swap_kb)<br>
trigger_kill_path(/<em>low_end=</em>/true);<br>
}<br>
<code class="notranslate">8) 配置装载与属性开关 新增：lmkd_config.h/.c</code>typedef struct {<br>
bool preaction_enable;<br>
int  preaction_min_adj;<br>
bool enable_madvise;<br>
int  preaction_cooldown_ms;<br>
float memory_high_ratio;</p>
<p>// weights &amp; thresholds<br>
float w_mem_psi, w_io_psi, w_cpu_psi, w_refault, w_swapin;<br>
float thrashing_score_thresh;</p>
<p>// backoff<br>
int backoff_ms_min, backoff_ms_max;</p>
<p>// protect &amp; group<br>
int fg_protect_adj;<br>
long fg_memory_min_bytes, fg_memory_low_bytes;<br>
bool kill_by_group;</p>
<p>// low end fallback<br>
long low_mem_kb, low_swap_kb;</p>
<p>// victim scoring<br>
float w_adj, w_rss, w_ui;<br>
} lmkd_config_t;</p>
<p>extern lmkd_config_t g_cfg;<br>
bool lmkd_load_config_from_props(void);<br>
<code class="notranslate"> </code>// lmkd_config.c 片段：从 system properties 读取（示例名）<br>
g_cfg.preaction_enable     = property_get_bool("lmkd.pre.enable", true);<br>
g_cfg.enable_madvise       = property_get_bool("lmkd.pre.madvise", false);<br>
g_cfg.memory_high_ratio    = property_get_float("lmkd.pre.memhigh.ratio", 0.85f);<br>
g_cfg.preaction_min_adj    = property_get_int32("lmkd.pre.minadj", 800);<br>
g_cfg.preaction_cooldown_ms= property_get_int32("lmkd.pre.cooldown.ms", 30);<br>
g_cfg.w_mem_psi            = property_get_float("lmkd.w.mempsi", 1.0f);<br>
g_cfg.w_io_psi             = property_get_float("lmkd.w.iopsi", 0.5f);<br>
g_cfg.w_cpu_psi            = property_get_float("lmkd.w.cpupsi", 0.2f);<br>
g_cfg.w_refault            = property_get_float("lmkd.w.refault", 0.8f);<br>
g_cfg.w_swapin             = property_get_float("lmkd.w.swapin", 0.6f);<br>
g_cfg.thrashing_score_thresh = property_get_float("lmkd.thrash.th", 1.0f);<br>
g_cfg.backoff_ms_min       = property_get_int32("lmkd.backoff.min", 50);<br>
g_cfg.backoff_ms_max       = property_get_int32("lmkd.backoff.max", 2000);<br>
g_cfg.fg_protect_adj       = property_get_int32("lmkd.fg.adj", 200);<br>
g_cfg.fg_memory_min_bytes  = property_get_int64("lmkd.fg.memmin", 64<em>1024</em>1024);<br>
g_cfg.fg_memory_low_bytes  = property_get_int64("lmkd.fg.memlow", 128<em>1024</em>1024);<br>
g_cfg.kill_by_group        = property_get_bool("lmkd.kill.group", true);<br>
g_cfg.low_mem_kb           = property_get_int64("lmkd.fallback.mem.kb", 150000);<br>
g_cfg.low_swap_kb          = property_get_int64("lmkd.fallback.swap.kb", 64000);<br>
g_cfg.w_adj                = property_get_float("lmkd.w.adj", 1.0f);<br>
g_cfg.w_rss                = property_get_float("lmkd.w.rss", 0.5f);<br>
g_cfg.w_ui                 = property_get_float("lmkd.w.ui", 2.0f);<br>
`<br>
设备侧可在 vendor_prop 或 init.*.rc 中设置这些属性，快速做 A/B 调参。</p>
<ol start="9">
<li>Android.bp 修改示例<br>
<code class="notranslate">cc_binary { name: "lmkd", srcs: [ "lmkd.c", "lmkd_psi.c", "lmkd_vmpressure.c", "lmkd_stats.c", "lmkd_cgroup.c", "lmkd_actions.c", "lmkd_config.c", ], cflags: [ "-DLMKD_PREACTIONS", "-DLMKD_CGROUP_V2", ], shared_libs: ["liblog", "libcutils"], // 其它保持不变 } </code></li>
<li>回归与观测建议（最小集）</li>
</ol>
<p>指标（statsd/trace 或 logcat 汇聚）：</p>
<p>preaction.count, preaction.success.rate, kill.count/hour, psi.mem.max, psi.io.max, backoff.time.avg, fg.kill.count（应≈0）</p>
<p>A/B 实验：统一场景（打开多 App + 大文件下载 + 后台编译/压缩），比较卡顿率、Kill 次数、前台留存。</p></div>
<div style="font-size:small;margin-top:8px;float:right;"></div>

<button class="btn btn-block" type="button" onclick="openComments()" id="cmButton">评论</button>
<div class="comments" id="comments"></div>

</div>
    <div id="footer"><div id="footer1">Copyright © <span id="copyrightYear"></span> <a href="https://lhmax2010.github.io">Blog Title</a></div>
<div id="footer2">
    <span id="runday"></span><span>Powered by <a href="https://meekdai.com/Gmeek.html" target="_blank">Gmeek</a></span>
</div>

<script>
var now=new Date();
document.getElementById("copyrightYear").innerHTML=now.getFullYear();

if(""!=""){
    var startSite=new Date("");
    var diff=now.getTime()-startSite.getTime();
    var diffDay=Math.floor(diff/(1000*60*60*24));
    document.getElementById("runday").innerHTML="网站运行"+diffDay+"天"+" • ";
}
</script></div>
</body>
<script>
var IconList={'sun': 'M8 10.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5zM8 12a4 4 0 100-8 4 4 0 000 8zM8 0a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0V.75A.75.75 0 018 0zm0 13a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0v-1.5A.75.75 0 018 13zM2.343 2.343a.75.75 0 011.061 0l1.06 1.061a.75.75 0 01-1.06 1.06l-1.06-1.06a.75.75 0 010-1.06zm9.193 9.193a.75.75 0 011.06 0l1.061 1.06a.75.75 0 01-1.06 1.061l-1.061-1.06a.75.75 0 010-1.061zM16 8a.75.75 0 01-.75.75h-1.5a.75.75 0 010-1.5h1.5A.75.75 0 0116 8zM3 8a.75.75 0 01-.75.75H.75a.75.75 0 010-1.5h1.5A.75.75 0 013 8zm10.657-5.657a.75.75 0 010 1.061l-1.061 1.06a.75.75 0 11-1.06-1.06l1.06-1.06a.75.75 0 011.06 0zm-9.193 9.193a.75.75 0 010 1.06l-1.06 1.061a.75.75 0 11-1.061-1.06l1.06-1.061a.75.75 0 011.061 0z', 'moon': 'M9.598 1.591a.75.75 0 01.785-.175 7 7 0 11-8.967 8.967.75.75 0 01.961-.96 5.5 5.5 0 007.046-7.046.75.75 0 01.175-.786zm1.616 1.945a7 7 0 01-7.678 7.678 5.5 5.5 0 107.678-7.678z', 'sync': 'M1.705 8.005a.75.75 0 0 1 .834.656 5.5 5.5 0 0 0 9.592 2.97l-1.204-1.204a.25.25 0 0 1 .177-.427h3.646a.25.25 0 0 1 .25.25v3.646a.25.25 0 0 1-.427.177l-1.38-1.38A7.002 7.002 0 0 1 1.05 8.84a.75.75 0 0 1 .656-.834ZM8 2.5a5.487 5.487 0 0 0-4.131 1.869l1.204 1.204A.25.25 0 0 1 4.896 6H1.25A.25.25 0 0 1 1 5.75V2.104a.25.25 0 0 1 .427-.177l1.38 1.38A7.002 7.002 0 0 1 14.95 7.16a.75.75 0 0 1-1.49.178A5.5 5.5 0 0 0 8 2.5Z', 'home': 'M6.906.664a1.749 1.749 0 0 1 2.187 0l5.25 4.2c.415.332.657.835.657 1.367v7.019A1.75 1.75 0 0 1 13.25 15h-3.5a.75.75 0 0 1-.75-.75V9H7v5.25a.75.75 0 0 1-.75.75h-3.5A1.75 1.75 0 0 1 1 13.25V6.23c0-.531.242-1.034.657-1.366l5.25-4.2Zm1.25 1.171a.25.25 0 0 0-.312 0l-5.25 4.2a.25.25 0 0 0-.094.196v7.019c0 .138.112.25.25.25H5.5V8.25a.75.75 0 0 1 .75-.75h3.5a.75.75 0 0 1 .75.75v5.25h2.75a.25.25 0 0 0 .25-.25V6.23a.25.25 0 0 0-.094-.195Z', 'github': 'M8 0c4.42 0 8 3.58 8 8a8.013 8.013 0 0 1-5.45 7.59c-.4.08-.55-.17-.55-.38 0-.27.01-1.13.01-2.2 0-.75-.25-1.23-.54-1.48 1.78-.2 3.65-.88 3.65-3.95 0-.88-.31-1.59-.82-2.15.08-.2.36-1.02-.08-2.12 0 0-.67-.22-2.2.82-.64-.18-1.32-.27-2-.27-.68 0-1.36.09-2 .27-1.53-1.03-2.2-.82-2.2-.82-.44 1.1-.16 1.92-.08 2.12-.51.56-.82 1.28-.82 2.15 0 3.06 1.86 3.75 3.64 3.95-.23.2-.44.55-.51 1.07-.46.21-1.61.55-2.33-.66-.15-.24-.6-.83-1.23-.82-.67.01-.27.38.01.53.34.19.73.9.82 1.13.16.45.68 1.31 2.69.94 0 .67.01 1.3.01 1.49 0 .21-.15.45-.55.38A7.995 7.995 0 0 1 0 8c0-4.42 3.58-8 8-8Z'};
var utterancesLoad=0;

let themeSettings={
    "dark": ["dark","moon","#00f0ff","dark-blue"],
    "light": ["light","sun","#ff5000","github-light"],
    "auto": ["auto","sync","","preferred-color-scheme"]
};
function changeTheme(mode, icon, color, utheme){
    document.documentElement.setAttribute("data-color-mode",mode);
    document.getElementById("themeSwitch").setAttribute("d",value=IconList[icon]);
    document.getElementById("themeSwitch").parentNode.style.color=color;
    if(utterancesLoad==1){utterancesTheme(utheme);}
}
function modeSwitch(){
    let currentMode=document.documentElement.getAttribute('data-color-mode');
    let newMode = currentMode === "light" ? "dark" : currentMode === "dark" ? "auto" : "light";
    localStorage.setItem("meek_theme", newMode);
    if(themeSettings[newMode]){
        changeTheme(...themeSettings[newMode]);
    }
}
function utterancesTheme(theme){
    const message={type:'set-theme',theme: theme};
    const iframe=document.getElementsByClassName('utterances-frame')[0];
    iframe.contentWindow.postMessage(message,'https://utteranc.es');
}
if(themeSettings[theme]){changeTheme(...themeSettings[theme]);}
console.log("\n %c Gmeek last https://github.com/Meekdai/Gmeek \n","padding:5px 0;background:#02d81d;color:#fff");
</script>

<script>
document.getElementById("pathHome").setAttribute("d",IconList["home"]);
document.getElementById("pathIssue").setAttribute("d",IconList["github"]);



function openComments(){
    cm=document.getElementById("comments");
    cmButton=document.getElementById("cmButton");
    cmButton.innerHTML="loading";
    span=document.createElement("span");
    span.setAttribute("class","AnimatedEllipsis");
    cmButton.appendChild(span);

    script=document.createElement("script");
    script.setAttribute("src","https://utteranc.es/client.js");
    script.setAttribute("repo","lhmax2010/lhmax2010.github.io");
    script.setAttribute("issue-term","title");
    
    if(localStorage.getItem("meek_theme")=="dark"){script.setAttribute("theme","dark-blue");}
    else if(localStorage.getItem("meek_theme")=="light") {script.setAttribute("theme","github-light");}
    else{script.setAttribute("theme","preferred-color-scheme");}
    
    script.setAttribute("crossorigin","anonymous");
    script.setAttribute("async","");
    cm.appendChild(script);

    int=self.setInterval("iFrameLoading()",200);
}

function iFrameLoading(){
    var utterances=document.getElementsByClassName('utterances');
    if(utterances.length==1){
        if(utterances[0].style.height!=""){
            utterancesLoad=1;
            int=window.clearInterval(int);
            document.getElementById("cmButton").style.display="none";
            console.log("utterances Load OK");
        }
    }
}



</script>


</html>
